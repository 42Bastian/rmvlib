<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>The Removers Libraries: The Removers Library Documentation</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<h1>The Removers Library Documentation</h1>
<p>
<h3 align="center">1.1.2 </h3><h2><a class="anchor" name="intro_sec">
Introduction</a></h2>
The library is intended to help programmers to write cool games for the <a href="http://en.wikipedia.org/wiki/Atari_Jaguar">Atari Jaguar</a>.<p>
Actually, the library is quite different from the first version we released in June 2006. The only common point is that the author of this library is Seb/The Removers.<p>
Indeed, I have worked hard to give a nice C interface to my library. Thus, it should now be easy to interface your own code (written in ASM or C) with my library. I will get into details of interfacing below.<h2><a class="anchor" name="philo_sec">
General philosophy</a></h2>
The library is essentially devoted to graphics operation. With it, you will be able to manipulate easily the OP sprites but you will also be able to do some nice effects with the blitter (this last part is still work in progress). You will also be able to easily manage the 8 joypads. On the sound side, I have adapted a ProTracker replay routine that is able to play modules up to 8 voices. It also allows to play samples simulteanously.<p>
I will now go quickly through * the library to introduce it to you.<h3><a class="anchor" name="display_subsec">
Display, GPU &amp; sprite manager</a></h3>
The core of the library is composed of <a class="el" href="display_8h.html" title="Display manager.">display.h</a> and <a class="el" href="sprite_8h.html" title="Display manager.">sprite.h</a>.<p>
The <a class="el" href="structdisplay.html">display</a> structure is an essential component of the library. A <a class="el" href="structdisplay.html">display</a> is a <a class="el" href="structsprite.html">sprite</a> container which is organized in layer. The maximal number of layers is 16. The layer are displayed on <a class="el" href="structscreen.html">screen</a> in ascending order so that layer 0 corresponds to the background and layer 15 corresponds to the foreground. A <a class="el" href="structdisplay.html">display</a> have coordinates on screens (<a class="el" href="structdisplay.html#14574f1784d84b7aa04d8a3d83ed2b72">display::x</a> and <a class="el" href="structdisplay.html#0ab653a2199638318a2dbbee08062b9c">display::y</a>). At most one <a class="el" href="structdisplay.html">display</a> may be viewed at a time.<p>
You can put <a class="el" href="structsprite.html">sprite</a> in a <a class="el" href="structdisplay.html">display</a> at the layer you wish. The <a class="el" href="structsprite.html">sprite</a> structure is a convenient way to manipulate OP sprites. A <a class="el" href="structsprite.html">sprite</a> can have arbitrary coordinates (<a class="el" href="structsprite.html#5b48711690e0d8fd0b25a82a18756816">sprite::x</a> and <a class="el" href="structsprite.html#a8dc6f3d689443af5ec63fd4d90ed519">sprite::y</a>) relative to the <a class="el" href="structdisplay.html">display</a> they belong to.<p>
The <a class="el" href="structsprite.html">sprite</a> can be unscaled or scaled (<a class="el" href="structsprite.html#a394695544784a6b64e10a5048593387">sprite::scaled</a>), visible or not (sprite::visible), animated or not (<a class="el" href="structsprite.html#daf6656b292f5f6236c8dd3ea4457735">sprite::animated</a>). They may have a "hot spot" different from the left upper corner (<a class="el" href="structsprite.html#abf5eff390d7222c61b15811512088d9">sprite::use_hotspot</a>, <a class="el" href="structsprite.html#2b3011ec3ce10cc3211fb7bdc17d3e8b">sprite::hx</a> and <a class="el" href="structsprite.html#3aef5a02d3b7ac32229ae776b468b278">sprite::hy</a>). An animated <a class="el" href="structsprite.html">sprite</a> is described by a simple array of <a class="el" href="structanimation__chunk.html">animation_chunk</a>.<p>
All the tedious details of the sprites are managed by the <a class="el" href="structdisplay.html">display</a> manager. The <a class="el" href="structdisplay.html">display</a> manager uses a GPU routine for maximal performance. It includes also a simple yet practical GPU subroutine manager. The <a class="el" href="structdisplay.html">display</a> manager should be initialised before use by calling the function <a class="el" href="display_8h.html#c1d421d8231a87be44954076badad7ad">init_display_driver</a>. You can then create a <a class="el" href="structdisplay.html">display</a> with the function <a class="el" href="sprite_8h.html#d35507fe3be38968539712d2e743d79e">new_display</a>. You can then fill the freshly created <a class="el" href="structdisplay.html">display</a> with sprites with <a class="el" href="sprite_8h.html#8439f1930459d5613bc2576ebaddc058">attach_sprite_to_display_at_layer</a>. To show the <a class="el" href="structdisplay.html">display</a>, you then simply have to call <a class="el" href="display_8h.html#477e81f40f0d2b23cb1c0a2d7882fba5">show_display</a>. It is also possible to remove easily a <a class="el" href="structsprite.html">sprite</a> from a <a class="el" href="structdisplay.html">display</a> with <a class="el" href="sprite_8h.html#318f6dac0cf3be3157548d09badda13e">detach_sprite_from_display</a>, change the layer of a <a class="el" href="structsprite.html">sprite</a> in a <a class="el" href="structdisplay.html">display</a> with <a class="el" href="sprite_8h.html#970107ca72a467e46e448fbb1462514d">change_sprite_layer</a>. You can even sort a layer of a <a class="el" href="structdisplay.html">display</a> with <a class="el" href="sprite_8h.html#dee6bffa6fb009e08ce22e260271ddee">sort_display_layer</a> so that you control the order of <a class="el" href="structdisplay.html">display</a> in a same layer.<h3><a class="anchor" name="coll_subsec">
Pixel precise collision</a></h3>
One common thing when you manipulate sprites is to check if two sprites collides. The file <a class="el" href="collision_8h.html" title="Pixel precise collision routine.">collision.h</a> provides you this functionnality. This collision routine has some limitations but this should not be too annoying. Indeed, it only manages unscaled <a class="el" href="structsprite.html">sprite</a> that are not horizontally flipped and whose <a class="el" href="structsprite.html#95000d86cccbadcd1222da63b9a0aa75">sprite::depth</a> is <a class="el" href="op_8h.html#40fbe8949b277afd0fac64228851b12a01b2376a263afddba89e359530acd8d2">DEPTH16</a>. However, the sprites can be animated or not and use a hot spot or not.<p>
To use the collision routine, you have first to use the <a class="el" href="structdisplay.html">display</a> manager. Then, you have to initialise this routine with the function <a class="el" href="collision_8h.html#7f4be2106b6556ad3881c58655d45243">init_collision_routine</a>. This last function copies the GPU subroutine in GPU ram at the address you give (for example &amp;<a class="el" href="display_8h.html#3070edaacfc862ded073b900e4a8d287">_GPU_FREE_RAM</a>). You can then launch a collision test with launch_collision_routine and asynchrounously get the result of the test with <a class="el" href="collision_8h.html#a8397216959cbc0822c9183342651b07">get_collision_result</a>. The collision routine not only determines if the two transparent <a class="el" href="structsprite.html">sprite</a> collide but also if their bounding box intersect.<h3><a class="anchor" name="fb2d_subsec">
Frame Buffers</a></h3>
The file <a class="el" href="screen_8h.html" title="Screen management.">screen.h</a> provides several facilities to allocate frame buffers (either simple buffer with <a class="el" href="screen_8h.html#e1d7deddbdd14236abb7bb650be20de9">alloc_simple_screen</a>, or double buffered with <a class="el" href="screen_8h.html#e4e147d137d67768a02c3ea36f510aa9">alloc_double_buffered_screens</a>, or double buffered with Z buffer with <a class="el" href="screen_8h.html#c9e72af4cef31769aec4d7fb935674a8">alloc_z_double_buffered_screens</a>). A <a class="el" href="structscreen.html">screen</a> is a structure that allows you to consider a part of memory as a frame buffer. You can <a class="el" href="structdisplay.html">display</a> a <a class="el" href="structscreen.html">screen</a> by building a corresponding <a class="el" href="structsprite.html">sprite</a> with <a class="el" href="screen_8h.html#0c1245ce7e31e9b018ecbc6434b976f5">sprite_of_screen</a> and then add it to the current <a class="el" href="structdisplay.html">display</a> with <a class="el" href="sprite_8h.html#8439f1930459d5613bc2576ebaddc058">attach_sprite_to_display_at_layer</a>.<p>
To manipulate the frame buffers, some 2D operations are implemented in <a class="el" href="fb2d_8h.html" title="2D Frame Buffer operations">fb2d.h</a>. The 2D frame buffer manager is still ongoing work. With this manager, you can copy a rectangular area of a <a class="el" href="structscreen.html">screen</a> into another <a class="el" href="structscreen.html">screen</a> with the desired copy <a class="el" href="fb2d_8h.html#1a6b6fb557d8d37d59700faf4e4c9167">mode</a>. This is done achieved with the function <a class="el" href="fb2d_8h.html#4cc39956d4b967c82458494b078eb882">fb2d_copy_straight</a>. You can also apply an <a class="el" href="structaffine__transform.html">affine_transform</a> while doing a transformed copy with <a class="el" href="fb2d_8h.html#8b7fa1d86cdbf3905987a81c35fbc589">fb2d_copy_transformed</a>. Thus, you can easily rotate a part of a <a class="el" href="structscreen.html">screen</a> by setting a rotation (with <a class="el" href="fb2d_8h.html#e87648e4c086e115be29d1808848f87c">fb2d_set_rotation</a>) as the considered affine transform. You can also compose transformation with <a class="el" href="fb2d_8h.html#2139ab12aef896735f4cb0ff7079eaa1">fb2d_compose_linear_transform</a>. It is easy to make a point match in the source <a class="el" href="structscreen.html">screen</a> and the target <a class="el" href="structscreen.html">screen</a> with the function fb2d_set_matching_point.<p>
Before using all these functionnalities, you should first initialise the <a class="el" href="structdisplay.html">display</a> manager and then the 2D frame buffer manager with <a class="el" href="fb2d_8h.html#503d0b9fdd2ece9497058abe9ebeeeb1">init_fb2d_manager</a>. Similarly to the collision routine, it takes the address in DSP ram where the DSP subroutine should be copied.<p>
Note that now there is a sound manager implemented (with v 1.1 of the library), the fb2d manager has moved to DSP ram.<h3><a class="anchor" name="joy_subsec">
Joypad management</a></h3>
The library offer you in <a class="el" href="joypad_8h.html" title="Joypad management.">joypad.h</a> a simple function to read the 8 joypad states. You simply have to call the function <a class="el" href="joypad_8h.html#4a358412f2f5f060dc86184bfa4e1ec3">read_joypad_state</a> and this will update the <a class="el" href="structjoypad__state.html">joypad_state</a> structure given.<h3><a class="anchor" name="inter_subsec">
Interrupts</a></h3>
Let me say a few words about the interrupt manager (of file <a class="el" href="interrupt_8h.html" title="Interrupts management.">interrupt.h</a>) despite this part is still under ongoing work. For the moment, you can just initialise interrupts with <a class="el" href="interrupt_8h.html#88ada49c1954d38252049786595d9a5f">init_interrupts</a>. This installs a generic interrupt manager that allows you to put several <a class="el" href="interrupt_8h.html#5b5f4eb5a4f31f7bb28052d16a53c799">irq_handler</a> to be run at each VBL. You simply have to put the address of the handler in the VblQueue array. You can also then wait for the next VBL to occur with <a class="el" href="interrupt_8h.html#cc0884f2032458e434145e6f082c370f">vsync</a>.<h3><a class="anchor" name="modplay_subsec">
Sound manager</a></h3>
The major improvement of version 1.1 of the library is the sound driver which implements functions described in <a class="el" href="sound_8h.html" title="Sound driver.">sound.h</a>. It offers you an 8 voices mixer which can play either 8 bits or 16 bits (big endian, signed) samples. Each voice can have its own volume, balance, frequency and quality. In addition, I have also worked on a Protracker replay routine that I have taken from the Amiga world and adapted so that it uses the above described mixer (which in spirit works like Paula) and optimised; it should be able to replay every 4/6/8 channels amiga module without any problem.<p>
Note finally that it is now easy to share the DSP between several tasks.<h3><a class="anchor" name="console_subsec">
Console</a></h3>
Another improvement of version 1.1 is the addition of the console (see <a class="el" href="console_8h.html" title="an on-screen console">console.h</a>).<h2><a class="anchor" name="inter_sec">
Interfacing your own program with the library</a></h2>
First you have to know that almost all the functions of my library requires that the structures given as arguments should be aligned at least on a long word (32 bits) boundary. The graphical data must even be aligned on a phrase (64 bits) boundary. A <a class="el" href="structdisplay.html">display</a> structure must even be aligned on a quad phrase boundary (but this is transparentally done with help of <a class="el" href="structmblock.html">mblock</a> structure).<p>
Then you also have to know that some part of my library assumes that you use the jlibc (Jaguar C library) I have also written.<p>
If you are using a C compiler to generate 68k code like gcc, it should be really easy. The only thing you need to know is that the type int stands for 32 bits integers. Thus, every parameter that is pushed on the stack when calling a function is 32 bits long.<p>
If you are using 68k ASM code, then the additionnal thing you need to know is that all registers but d0/d1/a0/a1 are preserved by function calls.<h2><a class="anchor" name="Installation">
Installation</a></h2>
The easiest way to install this library is to get your hands on a binary distribution of it. Then copy the header files in a directory where your C compiler will look after (include directory) and the objects and archive files in a directory where your linker will look after (lib directory).<p>
Provided that your compilation environment is correctly set up, you can also alternatively build the library with the 'make' command and then install it where you want with the 'make install' command. You might have to change the TARGET variable of the Makefile to indicate where you want all the files to be copied.<h2><a class="anchor" name="license_sec">
License</a></h2>
The following license applies to every file of the distribution except the file jaguar.inc.<p>
Copyright (C) 2006 Seb/The Removers <a href="http://removers.atari.org/">http://removers.atari.org/</a><p>
This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.<p>
This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.<p>
You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA<h2><a class="anchor" name="greet_sec">
Greetings</a></h2>
I would like to send some greetings to the Jagware Team (especially to Azrael, Fredifredo, GT Turbo, Mariaud, MetalKnuckles, Orion_, SCPCD, Zerosquare), Patrice Mandin, Fadest, Pocket, Odie One, Rajah Lone, Arethius, Vince, Mathias Domin, TNG (Symmetry &amp; Mr Spock), Starcat, Nick Harlow, Songbird, Jaysmith 2000 and of course to my good friend Stabylo. <hr size="1"><address style="text-align: right;"><small>Generated on Sun Nov 11 17:54:11 2007 for The Removers Libraries by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
